---
layout: post
title:  "Card Games and Logic Programming - For the Win!"
date:   2015-01-21 21:43:00
---

One of my favorite geek games is <a href="http://www.riograndegames.com/games.html?id=278">Dominion</a>.

<img src="https://github.com/jkutner/dominion-dukes/raw/master/images/dominion.jpeg" style="float:right; margin:0 0 10px 10px;cursor:pointer; cursor:hand;width: 150px; height: 150px;" border="0" alt="" />

It is a fantasy themed card game in which players try to win by purchasing "Victory" cards. The cards a player purchases go into his or her deck.  The Victory cards include Estate cards (worth 1 point and cost 2 copper each), Duchy cards (worth 3 points and cost 5 copper each), and Province cards (worth 6 points and cost 8 copper each).  So obviously, Province cards are more desirable - if you can afford them.<br /><br />There are strategies that allow a player to win by only buying Duchy cards.  The most viable of these strategies includes the use of a Duke card, which is worth one point for every Duchy card you possess but costs the same as a Duchy card.  So it can become more valuable than a Duchy.<div><img style="float:left; margin:0px 10px 10px 0px;cursor:pointer; cursor:hand;width: 98px; height: 157px;" border="0" alt="" src="https://github.com/jkutner/dominion-dukes/raw/master/images/duchy.jpeg" />The order in which the Duchy and Duke cards are acquired is important.  A game of Dominion can end abruptly. Thus, a player cannot easily predict how many Duchy cards (s)he will possess at the end of a game.  For example, purchasing Dukes in the first rounds would be a mistake because the Dukes are worth zero until the first Duchy is purchased.<br /><br />I have thought about the ideal order for purchasing Duchies and Dukes for a long time. The first few rounds are obvious:<br /><br />1. Purchase a Duchy - Total Score: 3 pts<br />2. Purchase a Duchy - Total Score: 6 pts<br />3. Purchase a Duchy - Total Score: 9 pts<br />4. Purchase a Duchy - Total Score: 12 pts<br />5. Purchase a Duke - Total Score: 16 pts<br /><br />But after those rounds, it becomes difficult to decide whether to buy another Duke (because they are now worth more than a Duchy), or to buy a Duchy (which would boost the value of the Dukes even further).<br /><br />To figure this out, I decided to write a program.  And because the algorithm would be highly recursive I chose to write it in <a href="http://en.wikipedia.org/wiki/Prolog">Prolog</a>.<br /><br /><b>Scoring and Playing</b><br />I started by writing the rules for scoring a deck.  The <span class="Apple-style-span">Deck</span> variable is a list of cards possessed by a player.  Each term in the list will be either a "<span class="Apple-style-span">duchy</span>" or a "<span class="Apple-style-span">duke</span>".<br /><br /><script src="https://gist.github.com/729756.js"> </script><br />After I was satisfied with the scoring predicates I began writing the predicates for building up all the possible decks a player could possess. The <span class="Apple-style-span">play</span> predicate uses recursion to simulate the purchases made while playing a game of Dominion.<br /><br /><script src="https://gist.github.com/729758.js"> </script><br />Once I was certain that the play predicate would backtrack through all the possible decks a player could have, I started to think about what would define a good deck - or even the best deck.<br /><br /><b>Finding the Best Deck</b><br /><div>I started by writing a predicate to find the deck with the highest score (I will call this value the "potential high score").  It didn't take long before I realized that this could not be the only criterion. Many decks result in the potential high score, and not all are good decks.  For example, one of the high scoring decks requires the purchase of nothing but Dukes at first - so the player's score will be zero for many rounds.<br /><br /><b>Greedy</b><br />I was curious if a <a href="http://en.wikipedia.org/wiki/Greedy_algorithm">greedy algorithm</a> that used a local maximum to decided the next card to purchase would result in he potential high score.  So I wrote one in Ruby.<br /><br /><script src="https://gist.github.com/729760.js"> </script><br />The greedy algorithm works for small deck sizes.  But it begins to diverge from the potential high score for larger deck sizes.<br /><br />Running the greedy algorithm for a game with 8 Dukes and 8 Duchies yields the following solution:<br /><br />1. Purchase a Duchy - Total Score: 3 pts<br />2. Purchase a Duchy - Total Score: 6 pts<br />3. Purchase a Duchy - Total Score: 9 pts<br />4. Purchase a Duke -   Total Score: 12 pts<br />5. Purchase a Duchy - Total Score: 16 pts<br />6. Purchase a Duke -   Total Score: 20 pts<br />7. Purchase a Duchy - Total Score: 25 pts<br />8. Purchase a Duke -   Total Score: 30 pts<br />9. Purchase a Duchy - Total Score: 36 pts<br />10. Purchase a Duke -   Total Score: 42 pts<br />11. Purchase a Duchy - Total Score: 49 pts<br />12. Purchase a Duke -   Total Score: 56 pts<br />13. Purchase a Duchy - Total Score: 64 pts<br /><br />The game ends when either the Dukes or Duchies run out.  In this case, the 13th purchase, a Duchy, is the last Duchy.<br /><br />I decided at this point that a deck must ultimately reach the potential high score in order to be considered the best deck.  But I also wanted to try and maximize the score after each card purchase - so if the game ends abruptly the player is not left with a very low score. To accomplish this I used a technique that is more like <a href="http://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a>, but I'm told its not exactly that. Regardless, it is perfect for Prolog.<br /><br /><b>Reverse Greedy</b><br />The algorithm I chose to implement is like a reverse greedy algorithm.  It makes a choice based on the deck with the highest score during any given round, but it starts with the final purchase.  This differs from the Ruby algorithm, which started with the first purchase.<br /><div><br />The algorithm starts by generating the set of all possible decks.  But it treats them like a tree of card choices through the power of recursion.  Thus we can picture the possible choices like this:</div><div><br /><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 200px; height: 270px;" src="https://github.com/jkutner/dominion-dukes/raw/master/images/Dukes/Slide1.jpg" border="0" alt="" /><br /></div><div>In the diagram above, notice that the far left branch is selecting all Duchies, and the far right branch is selecting all Dukes.  As the algorithm executes, it transforms the nodes of the tree into scores:</div><div><br /><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 200px; height: 270px;" src="https://github.com/jkutner/dominion-dukes/raw/master/images/Dukes/Slide2.jpg" border="0" alt="" /></div><div>The paths with all Duchies and all Dukes become more evident now.  Finally, the algorithm prunes the tree down to the path with the highest scores:</div><div><br /><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 200px; height: 270px;" src="https://github.com/jkutner/dominion-dukes/raw/master/images/Dukes/Slide3.jpg" border="0" alt="" />Because we have only illustrated a tree that has a depth of three, the best path is the "all Duchies" path.</div><br />At the core of this algorithm is the <span class="Apple-style-span">max_deck</span> predicate (note that I have left out some auxillary predicates that serve to kickstart the program as well as terminate the recursion).<br /><br /><script src="https://gist.github.com/729763.js"> </script><br />The variable <span class="Apple-style-span">SetOfDecks</span> starts as the set of all possible decks (its actually more of a stack because each successive round is added to the front of the list).  The variable <span class="Apple-style-span">N</span> records our position in <span class="Apple-style-span">SetOfDecks</span>.  And the variable <span class="Apple-style-span">Set</span> is the resulting best deck.<br /><br />The max_deck predicate has three stages:<br /><ol><li>Determine the maximum score at N of the decks in <span class="Apple-style-span">SetOfDecks</span> and store it in <span class="Apple-style-span">Max</span></li><li>Select all the Decks that have a score of <span class="Apple-style-span">Max</span> and store them in <span class="Apple-style-span">SetOfDecksWithMaxAtN</span></li><li>Recursively invoke <span class="Apple-style-span">max_deck</span> with the next position and the reduced set of decks</li></ol>I'm fairly certain there is a way to combine stages 1 and 2 into a single stage.  But my Prolog chops are not that sharp.</div><div><br /></div><div><br /></div><div>Now lets take a look at the individual predicates that make up the algorithm.  The <span class="Apple-style-span">max_n</span> predicate is fairly straight forward.  It recursively looks for the highest score at position N in the set of decks.  This is the meat of it:</div><div><br /><script src="https://gist.github.com/729765.js"> </script><br />The <span class="Apple-style-span">decks_with_n_of</span> predicate is only slightly more exciting.  It recursively looks through the set of decks for those that have a score of <span class="Apple-style-span">Max</span> at position N.  Like I said, this can probably be combined with <span class="Apple-style-span">max_n</span>.<br /><br /><script src="https://gist.github.com/729766.js"> </script><br />Both <span class="Apple-style-span">max_n</span> and <span class="Apple-style-span">decks_with_n_of</span> use a predicate called <span class="Apple-style-span">nth_score</span>.  This is a helper predicate that uses the score predicate described above:<br /><br /><script src="https://gist.github.com/729767.js"> </script><br />The tail predicate just selects all the elements after and including the Nth element.<br /><br />This approach is more effective that the greedy algorithm because it exhausts all possible solutions in a search for the optimal solution.  At each stage it reduces the solution set to only those that meet its criteria.<br /><br /><b>Results</b><br />Running this program for a game with 8 Dukes and 8 Duchies yields the following optimal solution:<br /><br />1. Purchase a Duchy - Total Score: 3 pts<br />2. Purchase a Duchy - Total Score: 6 pts<br />3. Purchase a Duchy - Total Score: 9 pts<br />4. Purchase a Duchy - Total Score: 12 pts<br />5. Purchase a Duke -   Total Score: 16 pts<br />6. Purchase a Duchy - Total Score: 20 pts<br />7. Purchase a Duke -   Total Score: 25 pts<br />8. Purchase a Duchy - Total Score: 30 pts<br />9. Purchase a Duke -   Total Score: 36 pts<br />10. Purchase a Duchy - Total Score: 42 pts<br />11. Purchase a Duke -   Total Score: 49 pts<br />12. Purchase a Duke -   Total Score: 56 pts<br />13. Purchase a Duke -   Total Score: 63 pts<br />14. Purchase a Duke -   Total Score: 70 pts<br />15. Purchase a Duchy - Total Score: 80 pts<br /><br />The game ends when there are no more Duchies left.  Notice that the score at each round for this deck is almost identical to the deck derived from the greedy algorithm.  They only diverge on the 13th round.<br /><br />Because the Prolog program does an exhaustive search, I was able to gather some interesting statistics about the 8 Duke/8 Duchy game.  There were 3,432 decks that were able to reach the potential high score of 80.  Of those, there were 16 that resulted in a suitable solution.  That is to say, the above deck is not the only deck with those scores at each round.  Thus, choosing which of those 16 decks to model a game after depends on outside factors - such as how the competitors are playing.<br /><br /><b>Conclusion</b><br />There are many factors that determine what strategy to use.  For example, if a player knows that other players are competing for the Dukes, (s)he may choose to grab them up before they run out.  Or if another player is trying to "race out the game" (i.e. end the game before an opposing player can get his or her strategy to pay off) one may choose to purchase cards in the way the greedy algorithm did - because its unlikely that the number of Victory cards in that person's deck will exceed five or six.<br /><br />This all makes Dominion a great game.  There is no rote pattern to follow. Each player must adapt his or her strategy as the game is played.<br /></div><br /><br />A full version of <a href="https://github.com/jkutner/dominion-dukes/blob/master/dukes.pro">the Prolog program is located here</a>.<br /><br />And a full version of <a href="https://github.com/jkutner/dominion-dukes/blob/master/dukes.rb">the greedy algorithm is located here</a>.</div>
